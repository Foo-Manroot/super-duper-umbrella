	En este documento se explica la estructura de la práctica y se adjuntan todas las cabeceras de las carpetas (donde se declaran y documentan las funciones utilizadas).

	Para implementar cada una de las partes, se han creado distintas carpetas con todos los archivos fuente y cabeceras necesarias:
		-> Para la implementación sólo con CPU, la carpeta cpu/
		-> Para la implementación con GPU (CUDA), la carpeta cuda/
		-> Para GPU (CUDA) con optimizaciones, la carpeta optimizada/
		-> Para la parte final, con OpenGL, la carpeta openGL/

	Para compilar cada una de las carpetas, se pueden usar los Makefile (sólo hace falta ejecutar `make`) para crear el ejecutable 'candy'. Para ver las opciones admitidas, se puede usar `./candy -h`. La salida es la siguiente (en todas las implementaciones es la misma):
>
>		Práctica de Ampliación de Programación Avanzada.
>		Daniel Estangüi y Miguel García
>	Uso correcto:
>	./candy [-hman:f:c:v]
>		-h
>			Muestra este mensaje de ayuda y sale del programa
>		-a | -m
>			Habilita la ejecución automática (-a) o manual (-m). Si no se especifica, se habilita la ejecución automática por defecto. Estas opciones son excluyentes
>		-n <nivel>
>			Si se especifica, establece el nivel de inicio (del 1 al 3)
>		-f <nº_filas>
>			Establece el número de filas de la matriz de juego
>		-c <nº_columnas>
>			Establece el número de columnas de la matriz de juego
>		-v
>			Incrementa el nivel de detalle
>

	Como se puede ver, '-v' permite aumentar el nivel de detalle, lo que aumenta el número de mensajes que se muestran. Hay tres niveles: LOG (sin -v), DEBUG (-v) y EXTRA (-vv).


	Se puede usar el Makefile global (el que está en src/) para compilar todo ejecutando `make`. Si se ejecuta, por ejemplo, `make cuda` se compila, ejecuta el programa de cuda/, tras lo que se limipian automáticamente todos los archivos generados. Lo mismo es aplicable al resto de implementaciones.


	Las optimizaciones realizadas son las siguientes (este es el mismo contenido que optimizada/optimizaciones.asdf):

	En gen_aleat gen_aleat_cuda() no tiene sentido usar memoria compartida, pues
sólo se accede a la matriz una vez (para escribir el valor generado).

	En realidad no se optimiza nada usando memoria compartida, dado que los núcleos
o bien no realizan suficientes lecturas o escrituras como para que compense el uso de
memoria compartida, o directamente no usan la memoria global más que para escribir el
resultado (como en gen_aleat_cuda). Sin embargo, somo se pide en la práctica, se ha
implementado en los siguientes núcleos:
	-> eliminar_fila_cuda
	-> eliminar_columna_cuda
	-> girar_matriz_cuda
	-> buscar_coinc_cuda_fila (aquí se usan dos matrices en memoria compartida)
	-> buscar_coinc_cuda_col (se usan dos matrices en memoria compartida)
	-> llenar_vacios_cuda (es el único núcleo en el que se disminuye realmente el
		número de accesos a memoria global)


	El único sitio donde sí puede llevar alguna ventaja el uso de memoria
compartida, debido al gran número de accesos, es buscar_lleno()


	Además, se ha usado el desenrrollamiento en el bucle para copiar el cuadrante de
3x3 en la memoria compartida, dentro del núcleo 'girar_matriz_cuda'


#########################################################################################
A partir de aquí, se adjuntan las cabeceras de todas las subcarpetas:


/******************************/
--> Carpeta cpu/
/******************************/

#ifndef _CANDY_H_
#define _CANDY_H_

#include "common.h"
#include "libutils.h"

/**
 * Movimientos de diamantes posibles
 */
#define MOV_DER 0
#define MOV_ABAJO 1
#define MOV_IZQ 2
#define MOV_ARRIBA 3

/* ------------------------ */
/* DECLARACIÓN DE FUNCIONES */
/* ------------------------ */
void recorrer_malla (Malla malla);

void recorrer_malla_giro (Malla malla);
void girar_matriz (int ejeY, int ejeX, Malla malla);

int es_posible_giro (int posY, int posX, Malla malla);
void eliminar_columna (int columna,Malla malla);

void recorrer_malla_reorden (Malla malla);
void reordenar_tablero (int posY,int posX,Malla malla);

void eliminar_fila (int fila, Malla malla);
void recorrer_malla_huecos (Malla malla);

void tratar_huecos(int posY, int posX, Malla malla);
void recorrer_malla_coincidencias (Malla malla);

void tratar_coincidencias(int posY, int posX, Malla malla);
void eliminar_coincidencias_eje(int posY, int posX,int eje,Malla malla);

void eliminar_coincidencias(int posY,int posX,int sen,Malla malla);
int buscar_coincidencias(int posY, int posX, int sen,Malla malla);

int son_iguales(Diamante d1,Diamante d2);
void mover_diamante(int posY, int posX, int mov, Malla malla);

int es_valido(int posY, int posX, int mov, Malla malla);
Diamante generar_diamante();

#endif
#ifndef _COMMON_H_
#define _COMMON_H_

#include <stdbool.h>

/***************************************************************************************
 * 	En este archivo se definen todas las estructuras, variables y códigos de salida
 * que se usan en toda la aplicación.
 ***************************************************************************************/


/* --------------------------- */
/* DEFINICIONES DE ESTRUCTURAS */
/* --------------------------- */

/**
 * Estructura para las dimensiones de la matriz
 */
typedef struct {

	int filas;
	int columnas;
} Dim;

/**
 * Estructura Diamante
 */
typedef struct {
    
	//id = {1,2,3,4,5,6,7,8} indican el tipo de diamante
	//id = {0} indica que no hay fiamante en ese hueco
	int id;
	const char *img;
} Diamante;

/**
 * Estructura para la matriz de juego
 */
typedef struct {

	int nivel;		/* Nivel actual */
	Dim dimens;		/* Dimensiones de la matriz */
	Diamante *matriz;	/* Matriz de juego */
} Malla;



/* ------------------------- */
/* DEFINICIONES DE ETIQUETAS */
/* ------------------------- */

/**
 * Nivel máximo en el juego
 */
#define MAX_NV 3

/**
 * Valor para representar un hueco en el tablero (diamante vacío)
 */
#define DIAMANTE_VACIO 0

/**
 * Mayor valor admitido para un diamante
 */
#define DIAMANTE_MAX 8



/* ------------------------------ */
/* CÓDIGOS DE SALIDA DE FUNCIONES */
/* ------------------------------ */

/**
 * Con cambios a la hora de recorrer la columna para tratar los huecos.
 */
#define CON_CAMBIOS 2

/**
 * Sin cambios a la hora de recorrer la columna para tratar los huecos.
 */
#define SIN_CAMBIOS 1

/**
 * La función acabó sin problemas.
 */
#define SUCCESS 0

/**
 * Éxito al procesar un argumento que requiere que se termine la ejecución (por ejemplo,
 * la opción '-h'.
 */
#define SUCC_ARGS 1

/**
 * Error al pasar los argumentos a la función.
 */
#define ERR_ARGS -1

/**
 * Error al abrir un archivo.
 */
#define ERR_ARCHIVO -2

/**
 * Error al gestionar la memoria (reservar, liberar...)
 */
#define ERR_MEM -3

#endif
#ifndef _LIBUTILS_H_
#define _LIBUTILS_H_

#include "common.h"
#include "menu.h"

#include <stdarg.h>
#include <stdbool.h>
#include <stdio.h>

#include <stdlib.h>
#include <time.h>
#include <unistd.h>
#include <sys/time.h>


/**
 * Mensaje de ayuda para mostrar el funcionamiento del programa.
 */
#define MSG_AYUDA "\n\
Práctica de Ampliación de Programación Avanzada.\n\
	Daniel Estangüi y Miguel García\n\
Uso correcto:\n\
joyas [-hman:f:c:v]\n\
	-h\n\
		Muestra este mensaje de ayuda y sale del programa\n\
	-a | -m\n\
		Habilita la ejecución automática (-a) o manual (-m). Si no se\
 especifica, se habilita la ejecución automática por defecto. Estas opciones son\
 excluyentes\n\
	-n <nivel>\n\
		Si se especifica, establece el nivel de inicio (del 1 al 3)\n\
	-f <nº_filas>\n\
		Establece el número de filas de la matriz de juego\n\
	-c <nº_columnas>\n\
		Establece el número de columnas de la matriz de juego\n\
	-v\n\
		Incrementa el nivel de detalle\n\
"

/**
 * Colores
 */
#define NOR "\x1B[0m" //Color normal
#define ROJ "\x1B[31m"
#define VER "\x1B[32m"
#define AMA "\x1B[33m"
#define AZU "\x1B[34m"
#define ROS "\x1B[35m"
#define CYN "\x1B[36m"
#define BLA "\x1B[30m"
#define RST "\x1B[0m" //RESET

/**
 * Niveles de detalle
 */
#define DETALLE_LOG	0
#define DETALLE_DEBUG	1
#define DETALLE_EXTRA	2

/* ------------------------ */
/* DECLARACIÓN DE FUNCIONES */
/* ------------------------ */
int procesar_args (int argc, char *argv []);
void imprimir_info ();

Malla ver_params ();
int guardar (Malla malla, const char *nombre_fichero);

int cargar (Malla *malla, const char *nombre_fichero);
int reservar_mem (Malla *malla);

int rellenar (Malla *malla);
void mostrar_malla (Malla malla);

Diamante crear_diamante (int num);
void imprimir (int detalle, const char *cadena, ...);

void cambiar_params (Malla malla);

#endif
#ifndef _MENU_H_
#define _MENU_H_

#include "candy.h"
#include "common.h"

#include <string.h>

/* ------------------------ */
/* DECLARACIÓN DE ETIQUETAS */
/* ------------------------ */

/**
 * Mensaje para mostrar las opciones del menú principal
 */
#define MSG_MENU "\n\
---------------------\n\
Opciones disponibles:\n\
	0.- Salir\n\
	1.- Mover diamante\n\
	2.- Bomba\n\
	3.- Guardar partida\n\
	4.- Cargar partida\n\
	5.- Cambiar nivel\n\
	6.- Jugada automática\n\
---------------------\n\
Introduzca la opción seleccionada: "

/* ------------------------ */
/* DECLARACIÓN DE FUNCIONES */
/* ------------------------ */
void menu (Malla malla);
int pedir_opcion (int min, int max);

void guardar_partida (Malla malla);
void cargar_partida (Malla *malla);

void cambiar_nivel (Malla *malla);
void mover (Malla malla);

void bomba (Malla malla);

#endif

/******************************/
--> Carpeta cuda/
/******************************/


#ifndef _CANDY_H_
#define _CANDY_H_

#include "common.h"
#include "libutils.h"
#include "kernel.cuh"

#include <sys/time.h>

/**
 * Movimientos de diamantes posibles
 */
#define MOV_DER 0
#define MOV_ABAJO 1
#define MOV_IZQ 2
#define MOV_ARRIBA 3

/* ------------------------ */
/* DECLARACIÓN DE FUNCIONES */
/* ------------------------ */
void mover_diamante(int posY, int posX, int mov, Malla malla);

int es_valido(int posY, int posX, int mov, Malla malla);


#endif
#ifndef _COMMON_H_
#define _COMMON_H_

#include <stdbool.h>

/***************************************************************************************
 * 	En este archivo se definen todas las estructuras, variables y códigos de salida
 * que se usan en toda la aplicación.
 ***************************************************************************************/


/* --------------------------- */
/* DEFINICIONES DE ESTRUCTURAS */
/* --------------------------- */

/**
 * Estructura para las dimensiones de la matriz
 */
typedef struct {

	int filas;
	int columnas;
} Dim;

/**
 * Estructura Diamante
 */
typedef struct {
    
	//id = {1,2,3,4,5,6,7,8} indican el tipo de diamante
	//id = {0} indica que no hay fiamante en ese hueco
	int id;
	const char *img;
} Diamante;

/**
 * Estructura para la matriz de juego
 */
typedef struct {

	int nivel;		/* Nivel actual */
	Dim dimens;		/* Dimensiones de la matriz */
	Diamante *matriz;	/* Matriz de juego */
} Malla;



/* ------------------------- */
/* DEFINICIONES DE ETIQUETAS */
/* ------------------------- */

/**
 * Nivel máximo en el juego
 */
#define MAX_NV 3

/**
 * Valor para representar un hueco en el tablero (diamante vacío)
 */
#define DIAMANTE_VACIO 0

/**
 * Mayor valor admitido para un diamante
 */
#define DIAMANTE_MAX 8



/* ------------------------------ */
/* CÓDIGOS DE SALIDA DE FUNCIONES */
/* ------------------------------ */

/**
 * Con cambios a la hora de recorrer la columna para tratar los huecos.
 */
#define CON_CAMBIOS 2

/**
 * Sin cambios a la hora de recorrer la columna para tratar los huecos.
 */
#define SIN_CAMBIOS 1

/**
 * Éxito al procesar un argumento que requiere que se termine la ejecución (por ejemplo,
 * la opción '-h'.
 */
#define SUCC_ARGS 1

/**
 * La función acabó sin problemas.
 */
#define SUCCESS 0

/**
 * Error al pasar los argumentos a la función.
 */
#define ERR_ARGS -1

/**
 * Error al abrir un archivo.
 */
#define ERR_ARCHIVO -2

/**
 * Error al gestionar memoria (reservar, liberar...).
 */
#define ERR_MEM -3

/**
 * Error producido en alguna función de CUDA.
 */
#define ERR_CUDA -4

/**
 * Error al intentar utilizar una matriz que no cabe en el dispositivo.
 */
#define ERR_TAM -5

#endif
#ifndef _KERNEL_CUH_
#define _KERNEL_CUH_

#include "common.h"
#include "libutils.h"

#include <cuda.h>
#include <curand.h>
#include <curand_kernel.h>
#include <math.h>

/**
 * Etiqueta para marcar elementos coincidentes en la matriz
 */
#define COINCIDE 1

/**
 * Etiqueta para marcar elementos que no coinciden en la matriz
 */
#define NO_COINCIDE 0

/**
 * Realiza la llamada a la función CUDA y comprueba el valor devuelto. Si hay algún
 * error, devuelve (return) ERR_CUDA.
 */
#define CUDA(err, x) do { if ((err = (x)) != cudaSuccess) {	\
	imprimir (DETALLE_LOG, "Error en la línea %d de '%s': %s\n",	\
			__LINE__, __FILE__, cudaGetErrorString (err)); \
	return ERR_CUDA;}} while(0)


/**
 * Realiza la llamada al núcleo CUDA y comprueba el código de error. Si hay algún
 * error, devuelve (return) ERR_CUDA.
 */
#define KERNEL(err, nombre, bloques, hilos, ...)				\
	imprimir (DETALLE_DEBUG,  "-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\n"		\
				"Lanzando el núcleo '%s' con las "		\
				"siguientes dimensiones: \n"			\
				"\tBloques: x=%d, y=%d\n"			\
				"\tHilos (por bloque): x=%d, y=%d, z=%d\n"	\
				"+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n",		\
				#nombre,					\
				bloques.x, bloques.y,				\
				hilos.x, hilos.y, hilos.z);			\
	nombre <<< (bloques), (hilos) >>> (__VA_ARGS__);			\
										\
	if ((err = cudaGetLastError ()) != cudaSuccess)				\
	{									\
		imprimir (DETALLE_LOG, "Error en la línea %d de '%s': "		\
				"%s\n", __LINE__, __FILE__,			\
				cudaGetErrorString (err));			\
		return ERR_CUDA;						\
	}


/* --------------------------------------- */
/* DECLARACIÓN DE FUNCIONES DE DISPOSITIVO */
/* --------------------------------------- */

/**
 * Comprueba si es posible realizar un giro de 3x3 en la posición dada.
 *
 * @param posY
 * 		Coordenada Y del eje a comprobar.
 *
 * @param posX
 * 		Coordenada X del eje a comprobar.
 *
 * @param dimens
 * 		Dimensiones de la matriz a comprobar.
 * 
 *
 * @return
 *		true si es posible.
 *		false si no lo es.
 */
__device__ bool comprobar_giro (int posY, int posX, Dim dimens);

/**
 * Busca el primer elemento no vacío por encima de la posición especificada.
 * Además, este elemento se convierte a DIAMANTE_VACIO.
 *
 * @param matriz
 *		Matriz en la que se ha de buscar el elemento.
 *
 * @param fila_ini
 *		Fila del primer elemento a comprobar.
 *
 * @param columna
 *		Columna a comprobar.
 *
 * @param dimens
 *		Dimensiones de la matriz.
 *
 *
 * @return
 *		El primer elemento encontrado, si había alguno.
 *		-1 si no se encontró ningún elemento no vacío.
 */
__device__ int buscar_lleno (int *matriz, int fila_ini, int columna, Dim dimens);

/* ---------------------- */
/* DECLARACIÓN DE NÚCLEOS */
/* ---------------------- */

/**
 * Genera un número aleatorio en base a la secuencia especificada y al índice del hilo.
 *
 * @param estado
 *		Estado utilizado para generar la secuencia.
 *
 * @param resultado
 *		Vector en el que se almacenará el número generado.
 *
 * @param min
 *		Límite inferior para generar un número (inclusivo).
 *
 * @param max
 *		Límite superior para generar un número (inclusivo).
 */
__global__ void gen_aleat_cuda (curandState *estado,
				int *resultado,
				int min,
				int max);
/**
 * Mueve todos los elementos a la izquierda de fila_bomba hacia su derecha. Cuando llega
 * al primer elemento, genera un nuevo elemento.
 *
 * @param semilla
 *		Elemento inicial para generar la secuencia.
 *
 * @param resultado
 *		Vector en el que se almacenarán los números generados.
 *
 * @param min
 *		Límite inferior para generar un número (inclusivo).
 *
 * @param max
 *		Límite superior para generar un número (inclusivo).
 *
 * @param dimens
 *		Dimensiones de la matriz resultado.

 *
 * @param fila_bomb
 *		Fila a eliminar.
 */
__global__ void eliminar_fila_cuda (unsigned long semilla,
				    int *resultado,
				    const int min,
				    const int max,
				    const Dim dimens,
				    int fila_bomba);

/**
 * Mueve todos los elementos a la izquierda de fila_bomba hacia su derecha. Cuando llega
 * al primer elemento, genera un nuevo elemento.
 *
 * @param semilla
 *		Elemento inicial para generar la secuencia.
 *
 * @param resultado
 *		Vector en el que se almacenarán los números generados.
 *
 * @param min
 *		Límite inferior para generar un número (inclusivo).
 *
 * @param max
 *		Límite superior para generar un número (inclusivo).
 *
 * @param dimens
 *		Dimensiones de la matriz resultado.
 *
 *
 * @param fila_bomb
 *		Fila a eliminar.
 */
__global__ void eliminar_columna_cuda (unsigned long semilla,
				       int *resultado,
				       const int min,
				       const int max,
				       const Dim dimens,
				       int col_bomba);
/**
 * Gira todos los elementos posibles en grupos de 3x3 (bomba III).
 *
 * @param resultado
 *		Vector que almacena la matriz que va a ser cambiada.
 *
 * @param dimens
 * 		Dimensiones de la matriz.
 */
__global__ void girar_matriz_cuda (int *resultado, Dim dimens);


/**
 * Comprueba si la fila contiene elementos repetidos.
 *
 * @param matriz
 *		Matriz con los valores actuales de los diamantes.
 *
 * @param dimens
 *		Estructura con las dimensiones de la matriz.
 *
 * @param coincidencias
 *		Matriz en la que se va a indicar si había alguna coincidencia.
 */
__global__ void busar_coinc_cuda_fila (int *matriz,
				       Dim dimens,
				       int *coincidencias);

/**
 * Comprueba si la columna contiene elementos repetidos.
 *
 * @param matriz
 *		Matriz con los valores actuales de los diamantes.
 *
 * @param dimens
 *		Estructura con las dimensiones de la matriz.
 *
 * @param coincidencias
 *		Matriz en la que se va a indicar si había alguna coincidencia.
 */
__global__ void busar_coinc_cuda_col (int *matriz,
				       Dim dimens,
				       int *coincidencias);

/**
 * Elimina todos los elementos que se haya visto que han coincidido.
 *
 *
 * @param matriz
 *		Matriz con los valores actuales de los diamantes.
 *
 * @param dimens
 *		Estructura con las dimensiones de la matriz.
 *
 * @param coincidencias
 *		Matriz con las coincidencias encontradas.
 */
__global__ void eliminar_coinc_cuda (int *matriz,
				     Dim dimens,
				     int *coincidencias);


/* ----------------------------------- */
/* DECLARACIÓN DE FUNCIONES AUXILIARES */
/* ----------------------------------- */


/**
 * Rellena la matriz de juego con diamantes aleatorios.
 *
 * @param malla
 * 		Estructura de tipo Malla (definida en 'common.h') con las dimensiones de
 * 	la matriz y su contenido.
 *
 *
 * @return
 * 		SUCCESS si todo ha salido correctamente.
 * 		ERR_CUDA si alguna función CUDA ha fallado.
 */
int matriz_aleat (Malla *malla);

/**
 * Obtiene las dimensiones de los hilos necesarias para ejecutar la matriz con las
 * dimensiones especificadas, teniendo en cuenta las limitaciones del dispositivo.
 *
 * @param bloques
 *		Elemento de tipo dim3 para almacenar las dimensiones de los bloques
 *	dentro de la rejilla (2D).
 *
 * @param hilos
 *		Elemento de tipo dim3 para almacenar las dimensiones de los hilos dentro
 *	de los bloques (3D).
 *
 * @param tam_matriz
 *		Estructura Dim (definida en 'commno.h') con las dimensiones de la matriz
 *	que se desea usar en el dispositivo.
 *
 *
 * @return
 *		SUCCESS si todo ha salido correctamente.
 *		ERR_CUDA si hubo algún error al obtener las características del
 *	dispositivo.
 *		ERR_TAM si la matriz especificada sobrepasa las capacidades del
 *	dispositivo.
 */
int obtener_dim (dim3 bloques, dim3 hilos, Dim tam_matriz);

/**
 * Función para ejecutar la bomba I (eliminar fila).
 *
 * @param fila_bomba
 *		Fila que se debe eliminar (poner a DIAMANTE_VACIO).
 *
 * @param malla
 *		Estructura con la información del juego.
 *
 *
 * @return
 *		SUCCESS si todo ha salido correctamente.
 *		CUDA_ERR si hubo algún error relacionado con CUDA.
 */
int bomba_fila (int fila_bomba, Malla *malla);


/**
 * Función para ejecutar la bomba II (eliminar columna).
 *
 * @param col_bomba
 *		Columna que se debe eliminar (poner a DIAMANTE_VACIO).
 *
 * @param malla
 *		Estructura con la información del juego.
 *
 *
 * @return
 *		SUCCESS si todo ha salido correctamente.
 *		CUDA_ERR si hubo algún error relacionado con CUDA.
 */
int bomba_columna (int col_bomba, Malla *malla);

/**
 * Función para ejecutar la bomba III (girar en grupos de 3x3).
 *
 * @param malla
 *		Estructura con toda la información del juego (matriz, nivel
 *	y dimensiones).
 */
int bomba_giro (Malla *malla);

/**
 * Busca coincidencias en la matriz y marca las casillas para ser eliminadas (las deja
 * como DIAMANTE_VACIO.
 *
 * @return
 *		SUCCESS si todo ha salido correctamente.
 *		ERR_CUDA si hubo algún error al obtener las características del
 *	dispositivo.
 *		ERR_TAM si la matriz especificada sobrepasa las capacidades del
 *	dispositivo.
 */
int eliminar_coincidencias (Malla *malla);

/**
 * Rellena los diamantes vacíos en la matriz.
 *
 * @return
 *		SUCCESS si todo ha salido correctamente.
 *		ERR_CUDA si hubo algún error al obtener las características del
 *	dispositivo.
 *		ERR_TAM si la matriz especificada sobrepasa las capacidades del
 *	dispositivo.
 */
int llenar_vacios (Malla *malla);

#endif
#ifndef _LIBUTILS_H_
#define _LIBUTILS_H_

#include "common.h"
#include "menu.h"
#include "kernel.cuh"

#include <stdarg.h>
#include <stdbool.h>
#include <stdio.h>

#include <stdlib.h>
#include <time.h>
#include <unistd.h>

/**
 * Mensaje de ayuda para mostrar el funcionamiento del programa.
 */
#define MSG_AYUDA "\n\
Práctica de Ampliación de Programación Avanzada.\n\
	Daniel Estangüi y Miguel García\n\
Uso correcto:\n\
joyas [-hman:f:c:v]\n\
	-h\n\
		Muestra este mensaje de ayuda y sale del programa\n\
	-a | -m\n\
		Habilita la ejecución automática (-a) o manual (-m). Si no se\
 especifica, se habilita la ejecución automática por defecto. Estas opciones son\
 excluyentes\n\
	-n <nivel>\n\
		Si se especifica, establece el nivel de inicio (del 1 al 3)\n\
	-f <nº_filas>\n\
		Establece el número de filas de la matriz de juego\n\
	-c <nº_columnas>\n\
		Establece el número de columnas de la matriz de juego\n\
	-v\n\
		Incrementa el nivel de detalle\n\
"

/**
 * Colores
 */
#define NOR "\x1B[0m" //Color normal
#define ROJ "\x1B[31m"
#define VER "\x1B[32m"
#define AMA "\x1B[33m"
#define AZU "\x1B[34m"
#define ROS "\x1B[35m"
#define CYN "\x1B[36m"
#define BLA "\x1B[30m"
#define RST "\x1B[0m" //RESET

/**
 * Niveles de detalle
 */
#define DETALLE_LOG	0
#define DETALLE_DEBUG	1
#define DETALLE_EXTRA	2

/* ------------------------ */
/* DECLARACIÓN DE FUNCIONES */
/* ------------------------ */

/**
 * Procesa los argumentos pasados por línea de comandos
 *
 * @param
 *		Número de argumentos pasados (nº de elementos en argv).
 *
 * @param argv
 *		Array de cadenas con los argumentos.
 *
 *
 * @return
 *		-> ERR_ARGS si se ha especificado alguna opción no reconocida.
 *		-> SUCCESS si se han procesado los argumentos correctamente y se
 *			debe proseguir con la ejecución.
 *		-> SUCC_ARGS si se ha procesado un argumento y se debe terminar la
 *			ejecución (p.ej.: tras procesar '-h').
 */

int procesar_args (int argc, char *argv []);

/**
 * Imprime toda la información de las variables globales del juego.
 */
void imprimir_info ();

/**
 * Cambia el valor de los parámetros del juego.
 *
 * @param nuevos_params
 * 		Estructura de tipo Malla (definida en 'common.h') con los nuevos nivel
 * 	y dimensiones del tablero de juego.
 */
void cambiar_params (Malla malla);

/**
 * Devuelve una estructura Malla con los valores especificados (nivel y dimensiones),
 * pero sin ninguna memoria reservada para la matriz.
 *
 *
 * @return
 * 		Una nueva instancia de tipo Malla, con los valores especificados por
 * 	línea de comandos.
 */
Malla ver_params ();

/**
 * Permite guardar la malla en el fichero especificado.
 *
 * @param malla
 * 		Estructura con toda la información del juego actual (nivel, dimensiones
 * 	de la matriz y el contenido de la matriz).
 *
 * @param nombre_fichero
 * 		Nombre del fichero en el que se deben guardar los datos. Si ya existe se
 * 	sobrescribirá; si no, se creará.
 *
 *
 * @return
 * 		SUCCESS si los datos se han guardado correctamente.
 * 		ERR_ARCHIVO si no se pudo abrir o cerrar correctamente el archivo.
 */
int guardar (Malla malla, const char *nombre_fichero);

/**
 * Carga desde el fichero especificado el juego guardado.
 *
 * @param malla
 * 		Estructura en la que se va a cargar la información del juego.
 *
 * @param nombre_fichero
 * 		Nombre del fichero que contiene la información del juego.
 *
 *
 * @return
 * 		SUCCESS si el archivo se cargó correctamente.
 * 		ERR_ARCHIVO si hubo algún error al abrir o cerrar el fichero.
 */
int cargar (Malla *malla, const char *nombre_fichero);

/**
 * Reserva la memoria necesaria para el tablero de juego
 *
 * @param malla
 * 		Estructura de tipo Malla (definida en 'common.h') con las dimensiones de
 * 	la matriz y su contenido.
 *
 *
 * @return
 * 		SUCCESS si todo ha salido correctamente.
 * 		ERR_MEM si hubo algún error al intentar reservar la memoria.
 */
int reservar_mem (Malla *malla);

/**
 * Rellena la matriz de juego con diamantes aleatorios.
 *
 * @param malla
 * 		Estructura de tipo Malla (definida en 'common.h') con las dimensiones de
 * 	la matriz y su contenido.
 *
 *
 * @return
 * 		SUCCESS si todo ha salido correctamente.
 * 		ERR_CUDA si alguna función CUDA ha fallado.
 */
int rellenar (Malla *malla);

/**
 * Imprime por pantalla el contenido de la matriz.
 *
 * @param malla
 * 		Estructura de tipo Malla (definida en 'common.h') con las dimensiones de
 * 	la matriz y su contenido.
 */
void mostrar_malla (Malla malla);

/**
 * Crea un diamante del tipo especificado.
 *
 * @param num
 * 		Número del tipo de diamante a crear.
 *
 * @return
 * 		Una nueva instancia de diamante.
 */
Diamante crear_diamante (int num);

/**
 * Imprime por pantalla la cadena pasada como argumento sólo si el nivel de detalle es
 * el especificado (o mayor).
 *
 * @param detalle
 * 		Nivel de detalle mínimo para imprimir el mensaje
 *
 * @param cadena
 * 		Cadena con formato para imprimir
 *
 * @param ...
 * 		Argumentos para el formato de la cadena
 */
void imprimir (int detalle, const char *cadena, ...);

/**
 * Obtiene el máximo diamante a generar, según el nivel especificado en la malla
 *
 * @param Malla
 *		Estructura con la información del nivel actual.
 *
 *
 * @return
 *		El valor máximo del diamante que se puede generar, en función del nivel.
 */
int max_nv (Malla malla);

/**
 * Obtiene el nivel de detalle actual.
 */
int ver_nv_detalle ();

#endif
#ifndef _MENU_H_
#define _MENU_H_

#include "candy.h"
#include "common.h"

#include <string.h>

/* ------------------------ */
/* DECLARACIÓN DE ETIQUETAS */
/* ------------------------ */

/**
 * Mensaje para mostrar las opciones del menú principal
 */
#define MSG_MENU "\n\
---------------------\n\
Opciones disponibles:\n\
	0.- Salir\n\
	1.- Mover diamante\n\
	2.- Bomba\n\
	3.- Guardar partida\n\
	4.- Cargar partida\n\
	5.- Cambiar nivel\n\
	6.- Jugada automática\n\
---------------------\n\
Introduzca la opción seleccionada: "

/* ------------------------ */
/* DECLARACIÓN DE FUNCIONES */
/* ------------------------ */
void menu (Malla malla);
int pedir_opcion (int min, int max);

void guardar_partida (Malla malla);
void cargar_partida (Malla *malla);

void cambiar_nivel (Malla *malla);
void mover (Malla malla);

void bomba (Malla malla);

#endif

/******************************/
--> Carpeta optimizada/
/******************************/

#ifndef _CANDY_H_
#define _CANDY_H_

#include "common.h"
#include "libutils.h"
#include "kernel.cuh"

#include <sys/time.h>

/**
 * Movimientos de diamantes posibles
 */
#define MOV_DER 0
#define MOV_ABAJO 1
#define MOV_IZQ 2
#define MOV_ARRIBA 3

/* ------------------------ */
/* DECLARACIÓN DE FUNCIONES */
/* ------------------------ */
void mover_diamante(int posY, int posX, int mov, Malla malla);

int es_valido(int posY, int posX, int mov, Malla malla);

#endif
#ifndef _COMMON_H_
#define _COMMON_H_

#include <stdbool.h>

/***************************************************************************************
 * 	En este archivo se definen todas las estructuras, variables y códigos de salida
 * que se usan en toda la aplicación.
 ***************************************************************************************/


/* --------------------------- */
/* DEFINICIONES DE ESTRUCTURAS */
/* --------------------------- */

/**
 * Estructura para las dimensiones de la matriz
 */
typedef struct {

	int filas;
	int columnas;
} Dim;

/**
 * Estructura Diamante
 */
typedef struct {
    
	//id = {1,2,3,4,5,6,7,8} indican el tipo de diamante
	//id = {0} indica que no hay fiamante en ese hueco
	int id;
	const char *img;
} Diamante;

/**
 * Estructura para la matriz de juego
 */
typedef struct {

	int nivel;		/* Nivel actual */
	Dim dimens;		/* Dimensiones de la matriz */
	Diamante *matriz;	/* Matriz de juego */
} Malla;



/* ------------------------- */
/* DEFINICIONES DE ETIQUETAS */
/* ------------------------- */

/**
 * Nivel máximo en el juego
 */
#define MAX_NV 3

/**
 * Valor para representar un hueco en el tablero (diamante vacío)
 */
#define DIAMANTE_VACIO 0

/**
 * Mayor valor admitido para un diamante
 */
#define DIAMANTE_MAX 8



/* ------------------------------ */
/* CÓDIGOS DE SALIDA DE FUNCIONES */
/* ------------------------------ */

/**
 * Con cambios a la hora de recorrer la columna para tratar los huecos.
 */
#define CON_CAMBIOS 2

/**
 * Sin cambios a la hora de recorrer la columna para tratar los huecos.
 */
#define SIN_CAMBIOS 1

/**
 * Éxito al procesar un argumento que requiere que se termine la ejecución (por ejemplo,
 * la opción '-h'.
 */
#define SUCC_ARGS 1

/**
 * La función acabó sin problemas.
 */
#define SUCCESS 0

/**
 * Error al pasar los argumentos a la función.
 */
#define ERR_ARGS -1

/**
 * Error al abrir un archivo.
 */
#define ERR_ARCHIVO -2

/**
 * Error al gestionar memoria (reservar, liberar...).
 */
#define ERR_MEM -3

/**
 * Error producido en alguna función de CUDA.
 */
#define ERR_CUDA -4

/**
 * Error al intentar utilizar una matriz que no cabe en el dispositivo.
 */
#define ERR_TAM -5

#endif
#ifndef _KERNEL_CUH_
#define _KERNEL_CUH_

#include "common.h"
#include "libutils.h"

#include <cuda.h>
#include <curand.h>
#include <curand_kernel.h>
#include <math.h>

/**
 * Etiqueta para marcar elementos coincidentes en la matriz
 */
#define COINCIDE 1

/**
 * Etiqueta para marcar elementos que no coinciden en la matriz
 */
#define NO_COINCIDE 0

/**
 * Realiza la llamada a la función CUDA y comprueba el valor devuelto. Si hay algún
 * error, devuelve (return) ERR_CUDA.
 */
#define CUDA(err, x) do { if ((err = (x)) != cudaSuccess) {	\
	imprimir (DETALLE_LOG, "Error en la línea %d de '%s': %s\n",	\
			__LINE__, __FILE__, cudaGetErrorString (err)); \
	return ERR_CUDA;}} while(0)


/**
 * Realiza la llamada al núcleo CUDA y comprueba el código de error. Si hay algún
 * error, devuelve (return) ERR_CUDA.
 */
#define KERNEL(err, nombre, bloques, hilos, ...)				\
	imprimir (DETALLE_DEBUG,  "-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\n"		\
				"Lanzando el núcleo '%s' con las "		\
				"siguientes dimensiones: \n"			\
				"\tBloques: x=%d, y=%d\n"			\
				"\tHilos (por bloque): x=%d, y=%d, z=%d\n"	\
				"+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n",		\
				#nombre,					\
				bloques.x, bloques.y,				\
				hilos.x, hilos.y, hilos.z);			\
	nombre <<< (bloques), (hilos) >>> (__VA_ARGS__);			\
										\
	if ((err = cudaGetLastError ()) != cudaSuccess)				\
	{									\
		imprimir (DETALLE_LOG, "Error en la línea %d de '%s': "		\
				"%s\n", __LINE__, __FILE__,			\
				cudaGetErrorString (err));			\
		return ERR_CUDA;						\
	}


/**
 * Realiza la llamada al núcleo CUDA que usa memoria compartida 
 * y comprueba el código de error. Si hay algún error, devuelve (return) ERR_CUDA.
 */
#define KERNEL_COMP(err, nombre, bloques, hilos, tam, ...)			\
	imprimir (DETALLE_DEBUG,  "-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\n"		\
				"Lanzando el núcleo '%s' con las "		\
				"siguientes dimensiones: \n"			\
				"\tBloques: x=%d, y=%d\n"			\
				"\tHilos (por bloque): x=%d, y=%d, z=%d\n"	\
				"\tMemoria compartida: %d bytes\n"		\
				"+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n",		\
				#nombre,					\
				bloques.x, bloques.y,				\
				hilos.x, hilos.y, hilos.z,			\
				tam);						\
	nombre <<< (bloques), (hilos) , (tam) >>> (__VA_ARGS__);		\
										\
	if ((err = cudaGetLastError ()) != cudaSuccess)				\
	{									\
		imprimir (DETALLE_LOG, "Error en la línea %d de '%s': "		\
				"%s\n", __LINE__, __FILE__,			\
				cudaGetErrorString (err));			\
		return ERR_CUDA;						\
	}



/* --------------------------------------- */
/* DECLARACIÓN DE FUNCIONES DE DISPOSITIVO */
/* --------------------------------------- */

/**
 * Comprueba si es posible realizar un giro de 3x3 en la posición dada.
 *
 * @param posY
 * 		Coordenada Y del eje a comprobar.
 *
 * @param posX
 * 		Coordenada X del eje a comprobar.
 *
 * @param dimens
 * 		Dimensiones de la matriz a comprobar.
 * 
 *
 * @return
 *		true si es posible.
 *		false si no lo es.
 */
__device__ bool comprobar_giro (int posY, int posX, Dim dimens);

/**
 * Busca el primer elemento no vacío por encima de la posición especificada.
 * Además, este elemento se convierte a DIAMANTE_VACIO.
 *
 * @param matriz
 *		Matriz en la que se ha de buscar el elemento.
 *
 * @param fila_ini
 *		Fila del primer elemento a comprobar.
 *
 * @param columna
 *		Columna a comprobar.
 *
 * @param dimens
 *		Dimensiones de la matriz.
 *
 *
 * @return
 *		El primer elemento encontrado, si había alguno.
 *		-1 si no se encontró ningún elemento no vacío.
 */
__device__ int buscar_lleno (int *matriz, int fila_ini, int columna, Dim dimens);

/* ---------------------- */
/* DECLARACIÓN DE NÚCLEOS */
/* ---------------------- */

/**
 * Genera un número aleatorio en base a la secuencia especificada y al índice del hilo.
 *
 * @param estado
 *		Estado utilizado para generar la secuencia.
 *
 * @param resultado
 *		Vector en el que se almacenará el número generado.
 *
 * @param min
 *		Límite inferior para generar un número (inclusivo).
 *
 * @param max
 *		Límite superior para generar un número (inclusivo).
 */
__global__ void gen_aleat_cuda (curandState *estado,
				int *resultado,
				int min,
				int max);
/**
 * Mueve todos los elementos a la izquierda de fila_bomba hacia su derecha. Cuando llega
 * al primer elemento, genera un nuevo elemento.
 *
 * @param semilla
 *		Elemento inicial para generar la secuencia.
 *
 * @param resultado
 *		Vector en el que se almacenarán los números generados.
 *
 * @param min
 *		Límite inferior para generar un número (inclusivo).
 *
 * @param max
 *		Límite superior para generar un número (inclusivo).
 *
 * @param dimens
 *		Dimensiones de la matriz resultado.

 *
 * @param fila_bomb
 *		Fila a eliminar.
 */
__global__ void eliminar_fila_cuda (unsigned long semilla,
				    int *resultado,
				    const int min,
				    const int max,
				    const Dim dimens,
				    int fila_bomba);

/**
 * Mueve todos los elementos a la izquierda de fila_bomba hacia su derecha. Cuando llega
 * al primer elemento, genera un nuevo elemento.
 *
 * @param semilla
 *		Elemento inicial para generar la secuencia.
 *
 * @param resultado
 *		Vector en el que se almacenarán los números generados.
 *
 * @param min
 *		Límite inferior para generar un número (inclusivo).
 *
 * @param max
 *		Límite superior para generar un número (inclusivo).
 *
 * @param dimens
 *		Dimensiones de la matriz resultado.
 *
 *
 * @param fila_bomb
 *		Fila a eliminar.
 */
__global__ void eliminar_columna_cuda (unsigned long semilla,
				       int *resultado,
				       const int min,
				       const int max,
				       const Dim dimens,
				       int col_bomba);
/**
 * Gira todos los elementos posibles en grupos de 3x3 (bomba III).
 *
 * @param resultado
 *		Vector que almacena la matriz que va a ser cambiada.
 *
 * @param dimens
 * 		Dimensiones de la matriz.
 */
__global__ void girar_matriz_cuda (int *resultado, Dim dimens);


/**
 * Comprueba si la fila contiene elementos repetidos.
 *
 * @param matriz
 *		Matriz con los valores actuales de los diamantes.
 *
 * @param dimens
 *		Estructura con las dimensiones de la matriz.
 *
 * @param coincidencias
 *		Matriz en la que se va a indicar si había alguna coincidencia.
 */
__global__ void busar_coinc_cuda_fila (int *matriz,
				       Dim dimens,
				       int *coincidencias);

/**
 * Comprueba si la columna contiene elementos repetidos.
 *
 * @param matriz
 *		Matriz con los valores actuales de los diamantes.
 *
 * @param dimens
 *		Estructura con las dimensiones de la matriz.
 *
 * @param coincidencias
 *		Matriz en la que se va a indicar si había alguna coincidencia.
 */
__global__ void busar_coinc_cuda_col (int *matriz,
				       Dim dimens,
				       int *coincidencias);

/**
 * Elimina todos los elementos que se haya visto que han coincidido.
 *
 *
 * @param matriz
 *		Matriz con los valores actuales de los diamantes.
 *
 * @param dimens
 *		Estructura con las dimensiones de la matriz.
 *
 * @param coincidencias
 *		Matriz con las coincidencias encontradas.
 */
__global__ void eliminar_coinc_cuda (int *matriz,
				     Dim dimens,
				     int *coincidencias);


/* ----------------------------------- */
/* DECLARACIÓN DE FUNCIONES AUXILIARES */
/* ----------------------------------- */


/**
 * Rellena la matriz de juego con diamantes aleatorios.
 *
 * @param malla
 * 		Estructura de tipo Malla (definida en 'common.h') con las dimensiones de
 * 	la matriz y su contenido.
 *
 *
 * @return
 * 		SUCCESS si todo ha salido correctamente.
 * 		ERR_CUDA si alguna función CUDA ha fallado.
 */
int matriz_aleat (Malla *malla);

/**
 * Obtiene las dimensiones de los hilos necesarias para ejecutar la matriz con las
 * dimensiones especificadas, teniendo en cuenta las limitaciones del dispositivo.
 *
 * @param bloques
 *		Elemento de tipo dim3 para almacenar las dimensiones de los bloques
 *	dentro de la rejilla (2D).
 *
 * @param hilos
 *		Elemento de tipo dim3 para almacenar las dimensiones de los hilos dentro
 *	de los bloques (3D).
 *
 * @param tam_matriz
 *		Estructura Dim (definida en 'commno.h') con las dimensiones de la matriz
 *	que se desea usar en el dispositivo.
 *
 *
 * @return
 *		SUCCESS si todo ha salido correctamente.
 *		ERR_CUDA si hubo algún error al obtener las características del
 *	dispositivo.
 *		ERR_TAM si la matriz especificada sobrepasa las capacidades del
 *	dispositivo.
 */
int obtener_dim (dim3 bloques, dim3 hilos, Dim tam_matriz);

/**
 * Función para ejecutar la bomba I (eliminar fila).
 *
 * @param fila_bomba
 *		Fila que se debe eliminar (poner a DIAMANTE_VACIO).
 *
 * @param malla
 *		Estructura con la información del juego.
 *
 *
 * @return
 *		SUCCESS si todo ha salido correctamente.
 *		CUDA_ERR si hubo algún error relacionado con CUDA.
 */
int bomba_fila (int fila_bomba, Malla *malla);


/**
 * Función para ejecutar la bomba II (eliminar columna).
 *
 * @param col_bomba
 *		Columna que se debe eliminar (poner a DIAMANTE_VACIO).
 *
 * @param malla
 *		Estructura con la información del juego.
 *
 *
 * @return
 *		SUCCESS si todo ha salido correctamente.
 *		CUDA_ERR si hubo algún error relacionado con CUDA.
 */
int bomba_columna (int col_bomba, Malla *malla);

/**
 * Función para ejecutar la bomba III (girar en grupos de 3x3).
 *
 * @param malla
 *		Estructura con toda la información del juego (matriz, nivel
 *	y dimensiones).
 */
int bomba_giro (Malla *malla);

/**
 * Busca coincidencias en la matriz y marca las casillas para ser eliminadas (las deja
 * como DIAMANTE_VACIO.
 *
 * @return
 *		SUCCESS si todo ha salido correctamente.
 *		ERR_CUDA si hubo algún error al obtener las características del
 *	dispositivo.
 *		ERR_TAM si la matriz especificada sobrepasa las capacidades del
 *	dispositivo.
 */
int eliminar_coincidencias (Malla *malla);

/**
 * Rellena los diamantes vacíos en la matriz.
 *
 * @return
 *		SUCCESS si todo ha salido correctamente.
 *		ERR_CUDA si hubo algún error al obtener las características del
 *	dispositivo.
 *		ERR_TAM si la matriz especificada sobrepasa las capacidades del
 *	dispositivo.
 */
int llenar_vacios (Malla *malla);

#endif
#ifndef _LIBUTILS_H_
#define _LIBUTILS_H_

#include "common.h"
#include "menu.h"
#include "kernel.cuh"

#include <stdarg.h>
#include <stdbool.h>
#include <stdio.h>

#include <stdlib.h>
#include <time.h>
#include <unistd.h>

/**
 * Mensaje de ayuda para mostrar el funcionamiento del programa.
 */
#define MSG_AYUDA "\n\
Práctica de Ampliación de Programación Avanzada.\n\
	Daniel Estangüi y Miguel García\n\
Uso correcto:\n\
joyas [-hman:f:c:v]\n\
	-h\n\
		Muestra este mensaje de ayuda y sale del programa\n\
	-a | -m\n\
		Habilita la ejecución automática (-a) o manual (-m). Si no se\
 especifica, se habilita la ejecución automática por defecto. Estas opciones son\
 excluyentes\n\
	-n <nivel>\n\
		Si se especifica, establece el nivel de inicio (del 1 al 3)\n\
	-f <nº_filas>\n\
		Establece el número de filas de la matriz de juego\n\
	-c <nº_columnas>\n\
		Establece el número de columnas de la matriz de juego\n\
	-v\n\
		Incrementa el nivel de detalle\n\
"

/**
 * Colores
 */
#define NOR "\x1B[0m" //Color normal
#define ROJ "\x1B[31m"
#define VER "\x1B[32m"
#define AMA "\x1B[33m"
#define AZU "\x1B[34m"
#define ROS "\x1B[35m"
#define CYN "\x1B[36m"
#define BLA "\x1B[30m"
#define RST "\x1B[0m" //RESET

/**
 * Niveles de detalle
 */
#define DETALLE_LOG	0
#define DETALLE_DEBUG	1
#define DETALLE_EXTRA	2

/* ------------------------ */
/* DECLARACIÓN DE FUNCIONES */
/* ------------------------ */

/**
 * Procesa los argumentos pasados por línea de comandos
 *
 * @param
 *		Número de argumentos pasados (nº de elementos en argv).
 *
 * @param argv
 *		Array de cadenas con los argumentos.
 *
 *
 * @return
 *		-> ERR_ARGS si se ha especificado alguna opción no reconocida.
 *		-> SUCCESS si se han procesado los argumentos correctamente y se
 *			debe proseguir con la ejecución.
 *		-> SUCC_ARGS si se ha procesado un argumento y se debe terminar la
 *			ejecución (p.ej.: tras procesar '-h').
 */

int procesar_args (int argc, char *argv []);

/**
 * Imprime toda la información de las variables globales del juego.
 */
void imprimir_info ();

/**
 * Cambia el valor de los parámetros del juego.
 *
 * @param nuevos_params
 * 		Estructura de tipo Malla (definida en 'common.h') con los nuevos nivel
 * 	y dimensiones del tablero de juego.
 */
void cambiar_params (Malla malla);

/**
 * Devuelve una estructura Malla con los valores especificados (nivel y dimensiones),
 * pero sin ninguna memoria reservada para la matriz.
 *
 *
 * @return
 * 		Una nueva instancia de tipo Malla, con los valores especificados por
 * 	línea de comandos.
 */
Malla ver_params ();

/**
 * Permite guardar la malla en el fichero especificado.
 *
 * @param malla
 * 		Estructura con toda la información del juego actual (nivel, dimensiones
 * 	de la matriz y el contenido de la matriz).
 *
 * @param nombre_fichero
 * 		Nombre del fichero en el que se deben guardar los datos. Si ya existe se
 * 	sobrescribirá; si no, se creará.
 *
 *
 * @return
 * 		SUCCESS si los datos se han guardado correctamente.
 * 		ERR_ARCHIVO si no se pudo abrir o cerrar correctamente el archivo.
 */
int guardar (Malla malla, const char *nombre_fichero);

/**
 * Carga desde el fichero especificado el juego guardado.
 *
 * @param malla
 * 		Estructura en la que se va a cargar la información del juego.
 *
 * @param nombre_fichero
 * 		Nombre del fichero que contiene la información del juego.
 *
 *
 * @return
 * 		SUCCESS si el archivo se cargó correctamente.
 * 		ERR_ARCHIVO si hubo algún error al abrir o cerrar el fichero.
 */
int cargar (Malla *malla, const char *nombre_fichero);

/**
 * Reserva la memoria necesaria para el tablero de juego
 *
 * @param malla
 * 		Estructura de tipo Malla (definida en 'common.h') con las dimensiones de
 * 	la matriz y su contenido.
 *
 *
 * @return
 * 		SUCCESS si todo ha salido correctamente.
 * 		ERR_MEM si hubo algún error al intentar reservar la memoria.
 */
int reservar_mem (Malla *malla);

/**
 * Rellena la matriz de juego con diamantes aleatorios.
 *
 * @param malla
 * 		Estructura de tipo Malla (definida en 'common.h') con las dimensiones de
 * 	la matriz y su contenido.
 *
 *
 * @return
 * 		SUCCESS si todo ha salido correctamente.
 * 		ERR_CUDA si alguna función CUDA ha fallado.
 */
int rellenar (Malla *malla);

/**
 * Imprime por pantalla el contenido de la matriz.
 *
 * @param malla
 * 		Estructura de tipo Malla (definida en 'common.h') con las dimensiones de
 * 	la matriz y su contenido.
 */
void mostrar_malla (Malla malla);

/**
 * Crea un diamante del tipo especificado.
 *
 * @param num
 * 		Número del tipo de diamante a crear.
 *
 * @return
 * 		Una nueva instancia de diamante.
 */
Diamante crear_diamante (int num);

/**
 * Imprime por pantalla la cadena pasada como argumento sólo si el nivel de detalle es
 * el especificado (o mayor).
 *
 * @param detalle
 * 		Nivel de detalle mínimo para imprimir el mensaje
 *
 * @param cadena
 * 		Cadena con formato para imprimir
 *
 * @param ...
 * 		Argumentos para el formato de la cadena
 */
void imprimir (int detalle, const char *cadena, ...);

/**
 * Obtiene el máximo diamante a generar, según el nivel especificado en la malla
 *
 * @param Malla
 *		Estructura con la información del nivel actual.
 *
 *
 * @return
 *		El valor máximo del diamante que se puede generar, en función del nivel.
 */
int max_nv (Malla malla);

/**
 * Obtiene el nivel de detalle actual.
 */
int ver_nv_detalle ();

#endif
#ifndef _MENU_H_
#define _MENU_H_

#include "candy.h"
#include "common.h"

#include <string.h>

/* ------------------------ */
/* DECLARACIÓN DE ETIQUETAS */
/* ------------------------ */

/**
 * Mensaje para mostrar las opciones del menú principal
 */
#define MSG_MENU "\n\
---------------------\n\
Opciones disponibles:\n\
	0.- Salir\n\
	1.- Mover diamante\n\
	2.- Bomba\n\
	3.- Guardar partida\n\
	4.- Cargar partida\n\
	5.- Cambiar nivel\n\
	6.- Jugada automática\n\
---------------------\n\
Introduzca la opción seleccionada: "

/* ------------------------ */
/* DECLARACIÓN DE FUNCIONES */
/* ------------------------ */
void menu (Malla malla);
int pedir_opcion (int min, int max);

void guardar_partida (Malla malla);
void cargar_partida (Malla *malla);

void cambiar_nivel (Malla *malla);
void mover (Malla malla);

void bomba (Malla malla);

#endif

/******************************/
--> Carpeta openGL/
/******************************/

#ifndef _CANDY_H_
#define _CANDY_H_

#include "common.h"
#include "libutils.h"
#include "kernel.cuh"

#include <sys/time.h>

#ifdef __APPLE__
	#include <GLUT/freeglut.h>
#else
	#include <GL/freeglut.h>
#endif


/**
 * Macro para convertir la coordenada X en la pantalla en coordenada respecto a la
 * ventana (para GLUT).
 */
#define CONVERTIR_COORD_RATON(x, y)						\
	x = ( ((float) x) / ((float) glutGet (GLUT_WINDOW_WIDTH))  ) - 0.5f;	\
	y = ( ((float) y) / ((float) glutGet (GLUT_WINDOW_HEIGHT)) ) - 0.5f;


/**
 * Macro para convertir la coordenada X con respecto a la ventana (GLUT) en coordenada
 * respecto a la pantalla.
 */
#define CONVERTIR_COORD_GLUT(x, y)						\
	x = ( ((float) x) + 0.5f * ((float) glutGet (GLUT_WINDOW_WIDTH))  );	\
	y = ( ((float) y) + 0.5f * ((float) glutGet (GLUT_WINDOW_HEIGHT)) );

/**
 * Archivo por defecto para guardar/cargar partidas
 */
#define ARCHIVO_PARTIDA_OPENGL "partida.asdf.pepe"


/**
 * Umbral para controlar los FPS de manera chapucera
 */
#define UMBRAL_FPS 100000

/**
 * En las coordenadas de GLUT, el lado de los cuadrados parece ser este (sacado a ojo)
 */
#define PASO_X 0.0673
#define PASO_Y 0.1346


/**
 * Movimientos de diamantes posibles
 */
#define MOV_DER 0
#define MOV_ABAJO 1
#define MOV_IZQ 2
#define MOV_ARRIBA 3

/* ------------------------ */
/* DECLARACIÓN DE FUNCIONES */
/* ------------------------ */
void mover_diamante(int posY, int posX, int mov, Malla malla);

int es_valido(int posY, int posX, int mov, Malla malla);

/**
 * Se encarga de todo lo necesario para iniciar la ventana con OpenGL.
 */
void iniciar_opengl (int argc, char *argv []);

/**
 * Dibuja una casilla de la matriz de diamantes.
 *
 * @param x
 * 		Posición X de la esquina superior izquierda de la celda.
 *
 * @param y
 * 		Posición Y de la esquina superior izquierda de la celda.
 *
 * @param posX
 * 		Posición X del elemento de la matriz a dibujar.
 *
 * @param posY
 * 		Posición Y del elemento de la matriz a dibujar.
 */
void dibujar_casilla (float x, float y, int posX, int posY);

/**
 * Dibuja los elementos en la pantalla.
 */
void render (void);

/**
 * Controla el evento al redimensionar la ventana.
 *
 * @param w
 * 		Nuevo ancho de la pantalla.
 *
 * @param h
 * 		Nueva altura de la pantalla.
 */
void manejador_redim (int w, int h);

/**
 * Dibuja los elementos en la pantalla.
 */
void manejador_gui (void);

/**
 * Procesa las teclas pulsadas durante el juego.
 *
 * @param tecla
 * 		Código de la tecla pulsada.
 *
 * @param x
 * 		Posición X del ratón respecto a la ventana de juego
 * 	cuando se pulsó la tecla.
 *
 * @param y
 * 		Posición Y del ratón respecto a la ventana de juego
 * 	cuando se pulsó la tecla.
 */
void manejador_teclas (unsigned char tecla, int x, int y);

/**
 * Obtiene la columna (más o menos) a la que pertenecen las coordenadas x e y
 * (respectivas al juego, según se usan en OpenGL).
 *
 * @param x
 * 		Posición X del ratón (convertida a coordenada OpenGL).
 *
 * @return
 * 		La columna, o -1 si está fuera de la matriz.
 */
int obtener_col (float x);

/**
 * Obtiene la fila (más o menos) a la que pertenecen las coordenadas x e y
 * (respectivas al juego, según se usan en OpenGL).
 *
 * @param y
 * 		Posición Y del ratón (convertida a coordenada OpenGL).
 *
 *
 * @return
 * 		La fila, o -1 si está fuera de la matriz.
 */
int obtener_fila (float y);
/**
 * Obtiene el movimiento seleccionado segúnlas casillas seleccionadas para intercambiar.
 *
 * @param fila
 * 		Fila de la nueva casilla seleccionada.
 *
 * @param col
 * 		Columna de la nueva casilla seleccionada.
 *
 *
 * @return
 * 		Un elemento de tipo MOV_* (definidos en candy.h), o ERR_MOV si no es un
 * 	movimiento aceptado (por ejemplo, se ha seleccionado otra vez la misma casilla).
 */
int obtener_movimiento (int fila, int col);

/**
 * Procesa un evento provocado por el ratón.
 *
 * @param boton
 * 		Botón del ratón pulsado.
 *
 * @param estado
 * 		Estado del botón.
 *
 * @param posX
 * 		Posición X del ratón cuando se pulsó el botón.
 *
 * @param posY
 * 		Posición Y del ratón cuando se pulsó el botón.
 */
void manejador_raton (int boton, int estado, int posX, int posY);

#endif
#ifndef _COMMON_H_
#define _COMMON_H_

#include <stdbool.h>

/***************************************************************************************
 * 	En este archivo se definen todas las estructuras, variables y códigos de salida
 * que se usan en toda la aplicación.
 ***************************************************************************************/


/* --------------------------- */
/* DEFINICIONES DE ESTRUCTURAS */
/* --------------------------- */

/**
 * Estructura para las dimensiones de la matriz
 */
typedef struct {

	int filas;
	int columnas;
} Dim;

/**
 * Estructura Diamante
 */
typedef struct {
    
	//id = {1,2,3,4,5,6,7,8} indican el tipo de diamante
	//id = {0} indica que no hay fiamante en ese hueco
	int id;
	const char *img;
} Diamante;

/**
 * Estructura para la matriz de juego
 */
typedef struct {

	int nivel;		/* Nivel actual */
	Dim dimens;		/* Dimensiones de la matriz */
	Diamante *matriz;	/* Matriz de juego */
} Malla;



/* ------------------------- */
/* DEFINICIONES DE ETIQUETAS */
/* ------------------------- */

/**
 * Nivel máximo en el juego
 */
#define MAX_NV 3

/**
 * Valor para representar un hueco en el tablero (diamante vacío)
 */
#define DIAMANTE_VACIO 0

/**
 * Mayor valor admitido para un diamante
 */
#define DIAMANTE_MAX 8



/* ------------------------------ */
/* CÓDIGOS DE SALIDA DE FUNCIONES */
/* ------------------------------ */

/**
 * Con cambios a la hora de recorrer la columna para tratar los huecos.
 */
#define CON_CAMBIOS 2

/**
 * Sin cambios a la hora de recorrer la columna para tratar los huecos.
 */
#define SIN_CAMBIOS 1

/**
 * Éxito al procesar un argumento que requiere que se termine la ejecución (por ejemplo,
 * la opción '-h'.
 */
#define SUCC_ARGS 1

/**
 * La función acabó sin problemas.
 */
#define SUCCESS 0

/**
 * Error al pasar los argumentos a la función.
 */
#define ERR_ARGS -1

/**
 * Error al abrir un archivo.
 */
#define ERR_ARCHIVO -2

/**
 * Error al gestionar memoria (reservar, liberar...).
 */
#define ERR_MEM -3

/**
 * Error producido en alguna función de CUDA.
 */
#define ERR_CUDA -4

/**
 * Error al intentar utilizar una matriz que no cabe en el dispositivo.
 */
#define ERR_TAM -5

/**
 * Movimiento no válido
 */
#define ERR_MOV -6

#endif
#ifndef _KERNEL_CUH_
#define _KERNEL_CUH_

#include "common.h"
#include "libutils.h"

#include <cuda.h>
#include <curand.h>
#include <curand_kernel.h>
#include <math.h>

/**
 * Etiqueta para marcar elementos coincidentes en la matriz
 */
#define COINCIDE 1

/**
 * Etiqueta para marcar elementos que no coinciden en la matriz
 */
#define NO_COINCIDE 0

/**
 * Realiza la llamada a la función CUDA y comprueba el valor devuelto. Si hay algún
 * error, devuelve (return) ERR_CUDA.
 */
#define CUDA(err, x) do { if ((err = (x)) != cudaSuccess) {	\
	imprimir (DETALLE_LOG, "Error en la línea %d de '%s': %s\n",	\
			__LINE__, __FILE__, cudaGetErrorString (err)); \
	return ERR_CUDA;}} while(0)


/**
 * Realiza la llamada al núcleo CUDA y comprueba el código de error. Si hay algún
 * error, devuelve (return) ERR_CUDA.
 */
#define KERNEL(err, nombre, bloques, hilos, ...)				\
	imprimir (DETALLE_DEBUG,  "-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\n"		\
				"Lanzando el núcleo '%s' con las "		\
				"siguientes dimensiones: \n"			\
				"\tBloques: x=%d, y=%d\n"			\
				"\tHilos (por bloque): x=%d, y=%d, z=%d\n"	\
				"+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n",		\
				#nombre,					\
				bloques.x, bloques.y,				\
				hilos.x, hilos.y, hilos.z);			\
	nombre <<< (bloques), (hilos) >>> (__VA_ARGS__);			\
										\
	if ((err = cudaGetLastError ()) != cudaSuccess)				\
	{									\
		imprimir (DETALLE_LOG, "Error en la línea %d de '%s': "		\
				"%s\n", __LINE__, __FILE__,			\
				cudaGetErrorString (err));			\
		return ERR_CUDA;						\
	}


/**
 * Realiza la llamada al núcleo CUDA que usa memoria compartida 
 * y comprueba el código de error. Si hay algún error, devuelve (return) ERR_CUDA.
 */
#define KERNEL_COMP(err, nombre, bloques, hilos, tam, ...)			\
	imprimir (DETALLE_DEBUG,  "-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\n"		\
				"Lanzando el núcleo '%s' con las "		\
				"siguientes dimensiones: \n"			\
				"\tBloques: x=%d, y=%d\n"			\
				"\tHilos (por bloque): x=%d, y=%d, z=%d\n"	\
				"\tMemoria compartida: %d bytes\n"		\
				"+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n",		\
				#nombre,					\
				bloques.x, bloques.y,				\
				hilos.x, hilos.y, hilos.z,			\
				tam);						\
	nombre <<< (bloques), (hilos) , (tam) >>> (__VA_ARGS__);		\
										\
	if ((err = cudaGetLastError ()) != cudaSuccess)				\
	{									\
		imprimir (DETALLE_LOG, "Error en la línea %d de '%s': "		\
				"%s\n", __LINE__, __FILE__,			\
				cudaGetErrorString (err));			\
		return ERR_CUDA;						\
	}



/* --------------------------------------- */
/* DECLARACIÓN DE FUNCIONES DE DISPOSITIVO */
/* --------------------------------------- */

/**
 * Comprueba si es posible realizar un giro de 3x3 en la posición dada.
 *
 * @param posY
 * 		Coordenada Y del eje a comprobar.
 *
 * @param posX
 * 		Coordenada X del eje a comprobar.
 *
 * @param dimens
 * 		Dimensiones de la matriz a comprobar.
 * 
 *
 * @return
 *		true si es posible.
 *		false si no lo es.
 */
__device__ bool comprobar_giro (int posY, int posX, Dim dimens);

/**
 * Busca el primer elemento no vacío por encima de la posición especificada.
 * Además, este elemento se convierte a DIAMANTE_VACIO.
 *
 * @param matriz
 *		Matriz en la que se ha de buscar el elemento.
 *
 * @param fila_ini
 *		Fila del primer elemento a comprobar.
 *
 * @param columna
 *		Columna a comprobar.
 *
 * @param dimens
 *		Dimensiones de la matriz.
 *
 *
 * @return
 *		El primer elemento encontrado, si había alguno.
 *		-1 si no se encontró ningún elemento no vacío.
 */
__device__ int buscar_lleno (int *matriz, int fila_ini, int columna, Dim dimens);

/* ---------------------- */
/* DECLARACIÓN DE NÚCLEOS */
/* ---------------------- */

/**
 * Genera un número aleatorio en base a la secuencia especificada y al índice del hilo.
 *
 * @param estado
 *		Estado utilizado para generar la secuencia.
 *
 * @param resultado
 *		Vector en el que se almacenará el número generado.
 *
 * @param min
 *		Límite inferior para generar un número (inclusivo).
 *
 * @param max
 *		Límite superior para generar un número (inclusivo).
 */
__global__ void gen_aleat_cuda (curandState *estado,
				int *resultado,
				int min,
				int max);
/**
 * Mueve todos los elementos a la izquierda de fila_bomba hacia su derecha. Cuando llega
 * al primer elemento, genera un nuevo elemento.
 *
 * @param semilla
 *		Elemento inicial para generar la secuencia.
 *
 * @param resultado
 *		Vector en el que se almacenarán los números generados.
 *
 * @param min
 *		Límite inferior para generar un número (inclusivo).
 *
 * @param max
 *		Límite superior para generar un número (inclusivo).
 *
 * @param dimens
 *		Dimensiones de la matriz resultado.

 *
 * @param fila_bomb
 *		Fila a eliminar.
 */
__global__ void eliminar_fila_cuda (unsigned long semilla,
				    int *resultado,
				    const int min,
				    const int max,
				    const Dim dimens,
				    int fila_bomba);

/**
 * Mueve todos los elementos a la izquierda de fila_bomba hacia su derecha. Cuando llega
 * al primer elemento, genera un nuevo elemento.
 *
 * @param semilla
 *		Elemento inicial para generar la secuencia.
 *
 * @param resultado
 *		Vector en el que se almacenarán los números generados.
 *
 * @param min
 *		Límite inferior para generar un número (inclusivo).
 *
 * @param max
 *		Límite superior para generar un número (inclusivo).
 *
 * @param dimens
 *		Dimensiones de la matriz resultado.
 *
 *
 * @param fila_bomb
 *		Fila a eliminar.
 */
__global__ void eliminar_columna_cuda (unsigned long semilla,
				       int *resultado,
				       const int min,
				       const int max,
				       const Dim dimens,
				       int col_bomba);
/**
 * Gira todos los elementos posibles en grupos de 3x3 (bomba III).
 *
 * @param resultado
 *		Vector que almacena la matriz que va a ser cambiada.
 *
 * @param dimens
 * 		Dimensiones de la matriz.
 */
__global__ void girar_matriz_cuda (int *resultado, Dim dimens);


/**
 * Comprueba si la fila contiene elementos repetidos.
 *
 * @param matriz
 *		Matriz con los valores actuales de los diamantes.
 *
 * @param dimens
 *		Estructura con las dimensiones de la matriz.
 *
 * @param coincidencias
 *		Matriz en la que se va a indicar si había alguna coincidencia.
 */
__global__ void busar_coinc_cuda_fila (int *matriz,
				       Dim dimens,
				       int *coincidencias);

/**
 * Comprueba si la columna contiene elementos repetidos.
 *
 * @param matriz
 *		Matriz con los valores actuales de los diamantes.
 *
 * @param dimens
 *		Estructura con las dimensiones de la matriz.
 *
 * @param coincidencias
 *		Matriz en la que se va a indicar si había alguna coincidencia.
 */
__global__ void busar_coinc_cuda_col (int *matriz,
				       Dim dimens,
				       int *coincidencias);

/**
 * Elimina todos los elementos que se haya visto que han coincidido.
 *
 *
 * @param matriz
 *		Matriz con los valores actuales de los diamantes.
 *
 * @param dimens
 *		Estructura con las dimensiones de la matriz.
 *
 * @param coincidencias
 *		Matriz con las coincidencias encontradas.
 */
__global__ void eliminar_coinc_cuda (int *matriz,
				     Dim dimens,
				     int *coincidencias);


/* ----------------------------------- */
/* DECLARACIÓN DE FUNCIONES AUXILIARES */
/* ----------------------------------- */


/**
 * Rellena la matriz de juego con diamantes aleatorios.
 *
 * @param malla
 * 		Estructura de tipo Malla (definida en 'common.h') con las dimensiones de
 * 	la matriz y su contenido.
 *
 *
 * @return
 * 		SUCCESS si todo ha salido correctamente.
 * 		ERR_CUDA si alguna función CUDA ha fallado.
 */
int matriz_aleat (Malla *malla);

/**
 * Obtiene las dimensiones de los hilos necesarias para ejecutar la matriz con las
 * dimensiones especificadas, teniendo en cuenta las limitaciones del dispositivo.
 *
 * @param bloques
 *		Elemento de tipo dim3 para almacenar las dimensiones de los bloques
 *	dentro de la rejilla (2D).
 *
 * @param hilos
 *		Elemento de tipo dim3 para almacenar las dimensiones de los hilos dentro
 *	de los bloques (3D).
 *
 * @param tam_matriz
 *		Estructura Dim (definida en 'commno.h') con las dimensiones de la matriz
 *	que se desea usar en el dispositivo.
 *
 *
 * @return
 *		SUCCESS si todo ha salido correctamente.
 *		ERR_CUDA si hubo algún error al obtener las características del
 *	dispositivo.
 *		ERR_TAM si la matriz especificada sobrepasa las capacidades del
 *	dispositivo.
 */
int obtener_dim (dim3 bloques, dim3 hilos, Dim tam_matriz);

/**
 * Función para ejecutar la bomba I (eliminar fila).
 *
 * @param fila_bomba
 *		Fila que se debe eliminar (poner a DIAMANTE_VACIO).
 *
 * @param malla
 *		Estructura con la información del juego.
 *
 *
 * @return
 *		SUCCESS si todo ha salido correctamente.
 *		CUDA_ERR si hubo algún error relacionado con CUDA.
 */
int bomba_fila (int fila_bomba, Malla *malla);


/**
 * Función para ejecutar la bomba II (eliminar columna).
 *
 * @param col_bomba
 *		Columna que se debe eliminar (poner a DIAMANTE_VACIO).
 *
 * @param malla
 *		Estructura con la información del juego.
 *
 *
 * @return
 *		SUCCESS si todo ha salido correctamente.
 *		CUDA_ERR si hubo algún error relacionado con CUDA.
 */
int bomba_columna (int col_bomba, Malla *malla);

/**
 * Función para ejecutar la bomba III (girar en grupos de 3x3).
 *
 * @param malla
 *		Estructura con toda la información del juego (matriz, nivel
 *	y dimensiones).
 */
int bomba_giro (Malla *malla);

/**
 * Busca coincidencias en la matriz y marca las casillas para ser eliminadas (las deja
 * como DIAMANTE_VACIO.
 *
 * @return
 *		SUCCESS si todo ha salido correctamente.
 *		ERR_CUDA si hubo algún error al obtener las características del
 *	dispositivo.
 *		ERR_TAM si la matriz especificada sobrepasa las capacidades del
 *	dispositivo.
 */
int eliminar_coincidencias (Malla *malla);

/**
 * Rellena los diamantes vacíos en la matriz.
 *
 * @return
 *		SUCCESS si todo ha salido correctamente.
 *		ERR_CUDA si hubo algún error al obtener las características del
 *	dispositivo.
 *		ERR_TAM si la matriz especificada sobrepasa las capacidades del
 *	dispositivo.
 */
int llenar_vacios (Malla *malla);

#endif
#ifndef _LIBUTILS_H_
#define _LIBUTILS_H_

#include "common.h"
#include "menu.h"
#include "kernel.cuh"

#include <stdarg.h>
#include <stdbool.h>
#include <stdio.h>

#include <stdlib.h>
#include <time.h>
#include <unistd.h>

/**
 * Mensaje de ayuda para mostrar el funcionamiento del programa.
 */
#define MSG_AYUDA "\n\
Práctica de Ampliación de Programación Avanzada.\n\
	Daniel Estangüi y Miguel García\n\
Uso correcto:\n\
joyas [-hman:f:c:v]\n\
	-h\n\
		Muestra este mensaje de ayuda y sale del programa\n\
	-a | -m\n\
		Habilita la ejecución automática (-a) o manual (-m). Si no se\
 especifica, se habilita la ejecución automática por defecto. Estas opciones son\
 excluyentes\n\
	-n <nivel>\n\
		Si se especifica, establece el nivel de inicio (del 1 al 3)\n\
	-f <nº_filas>\n\
		Establece el número de filas de la matriz de juego\n\
	-c <nº_columnas>\n\
		Establece el número de columnas de la matriz de juego\n\
	-v\n\
		Incrementa el nivel de detalle\n\
"

/**
 * Colores
 */
#define NOR "\x1B[0m" //Color normal
#define ROJ "\x1B[31m"
#define VER "\x1B[32m"
#define AMA "\x1B[33m"
#define AZU "\x1B[34m"
#define ROS "\x1B[35m"
#define CYN "\x1B[36m"
#define BLA "\x1B[30m"
#define RST "\x1B[0m" //RESET

/**
 * Niveles de detalle
 */
#define DETALLE_LOG	0
#define DETALLE_DEBUG	1
#define DETALLE_EXTRA	2

/* ------------------------ */
/* DECLARACIÓN DE FUNCIONES */
/* ------------------------ */

/**
 * Procesa los argumentos pasados por línea de comandos
 *
 * @param
 *		Número de argumentos pasados (nº de elementos en argv).
 *
 * @param argv
 *		Array de cadenas con los argumentos.
 *
 *
 * @return
 *		-> ERR_ARGS si se ha especificado alguna opción no reconocida.
 *		-> SUCCESS si se han procesado los argumentos correctamente y se
 *			debe proseguir con la ejecución.
 *		-> SUCC_ARGS si se ha procesado un argumento y se debe terminar la
 *			ejecución (p.ej.: tras procesar '-h').
 */

int procesar_args (int argc, char *argv []);

/**
 * Imprime toda la información de las variables globales del juego.
 */
void imprimir_info ();

/**
 * Cambia el valor de los parámetros del juego.
 *
 * @param nuevos_params
 * 		Estructura de tipo Malla (definida en 'common.h') con los nuevos nivel
 * 	y dimensiones del tablero de juego.
 */
void cambiar_params (Malla malla);

/**
 * Devuelve una estructura Malla con los valores especificados (nivel y dimensiones),
 * pero sin ninguna memoria reservada para la matriz.
 *
 *
 * @return
 * 		Una nueva instancia de tipo Malla, con los valores especificados por
 * 	línea de comandos.
 */
Malla ver_params ();

/**
 * Permite guardar la malla en el fichero especificado.
 *
 * @param malla
 * 		Estructura con toda la información del juego actual (nivel, dimensiones
 * 	de la matriz y el contenido de la matriz).
 *
 * @param nombre_fichero
 * 		Nombre del fichero en el que se deben guardar los datos. Si ya existe se
 * 	sobrescribirá; si no, se creará.
 *
 *
 * @return
 * 		SUCCESS si los datos se han guardado correctamente.
 * 		ERR_ARCHIVO si no se pudo abrir o cerrar correctamente el archivo.
 */
int guardar (Malla malla, const char *nombre_fichero);

/**
 * Carga desde el fichero especificado el juego guardado.
 *
 * @param malla
 * 		Estructura en la que se va a cargar la información del juego.
 *
 * @param nombre_fichero
 * 		Nombre del fichero que contiene la información del juego.
 *
 *
 * @return
 * 		SUCCESS si el archivo se cargó correctamente.
 * 		ERR_ARCHIVO si hubo algún error al abrir o cerrar el fichero.
 */
int cargar (Malla *malla, const char *nombre_fichero);

/**
 * Reserva la memoria necesaria para el tablero de juego
 *
 * @param malla
 * 		Estructura de tipo Malla (definida en 'common.h') con las dimensiones de
 * 	la matriz y su contenido.
 *
 *
 * @return
 * 		SUCCESS si todo ha salido correctamente.
 * 		ERR_MEM si hubo algún error al intentar reservar la memoria.
 */
int reservar_mem (Malla *malla);

/**
 * Rellena la matriz de juego con diamantes aleatorios.
 *
 * @param malla
 * 		Estructura de tipo Malla (definida en 'common.h') con las dimensiones de
 * 	la matriz y su contenido.
 *
 *
 * @return
 * 		SUCCESS si todo ha salido correctamente.
 * 		ERR_CUDA si alguna función CUDA ha fallado.
 */
int rellenar (Malla *malla);

/**
 * Imprime por pantalla el contenido de la matriz.
 *
 * @param malla
 * 		Estructura de tipo Malla (definida en 'common.h') con las dimensiones de
 * 	la matriz y su contenido.
 */
void mostrar_malla (Malla malla);

/**
 * Crea un diamante del tipo especificado.
 *
 * @param num
 * 		Número del tipo de diamante a crear.
 *
 * @return
 * 		Una nueva instancia de diamante.
 */
Diamante crear_diamante (int num);

/**
 * Imprime por pantalla la cadena pasada como argumento sólo si el nivel de detalle es
 * el especificado (o mayor).
 *
 * @param detalle
 * 		Nivel de detalle mínimo para imprimir el mensaje
 *
 * @param cadena
 * 		Cadena con formato para imprimir
 *
 * @param ...
 * 		Argumentos para el formato de la cadena
 */
void imprimir (int detalle, const char *cadena, ...);

/**
 * Obtiene el máximo diamante a generar, según el nivel especificado en la malla
 *
 * @param Malla
 *		Estructura con la información del nivel actual.
 *
 *
 * @return
 *		El valor máximo del diamante que se puede generar, en función del nivel.
 */
int max_nv (Malla malla);

/**
 * Obtiene el nivel de detalle actual.
 */
int ver_nv_detalle ();

/**
 * Convierte un carácter a su valor numérico. Por ejemplo, si se introduce '9', se
 * devuelve el valor entero 9.
 *
 * @param caracter
 * 		El carácter a convertir.
 *
 * 
 * @return
 * 		El valor numérico representado con ese carácter, o -1 si no era
 * 	un número. */
int char_to_int (char caracter);

#endif
#ifndef _MENU_H_
#define _MENU_H_

#include "candy.h"
#include "common.h"

#include <string.h>

/* ------------------------ */
/* DECLARACIÓN DE ETIQUETAS */
/* ------------------------ */

/**
 * Mensaje para mostrar las opciones del menú principal
 */
#define MSG_MENU "\n\
---------------------\n\
Opciones disponibles:\n\
	0.- Salir\n\
	1.- Mover diamante\n\
	2.- Bomba\n\
	3.- Guardar partida\n\
	4.- Cargar partida\n\
	5.- Cambiar nivel\n\
	6.- Jugada automática\n\
---------------------\n\
Introduzca la opción seleccionada: "

/* ------------------------ */
/* DECLARACIÓN DE FUNCIONES */
/* ------------------------ */
void menu (Malla malla);
int pedir_opcion (int min, int max);

void guardar_partida (Malla malla);
void cargar_partida (Malla *malla);

void cambiar_nivel (Malla *malla);
void mover (Malla malla);

void bomba (Malla malla);

#endif
