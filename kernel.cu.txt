/**
 * Busca las mejores jugadas por filas
 *
 * @param matriz
 *		Matriz con los valores actuales de los diamantes.
 *
 * @param dimens
 *		Estructura con las dimensiones de la matriz.
 *
 * @param mat2
 *		Matriz en la que se va a indicar los valores de las mejores 
 *		jugadas por posicion
 *
 * @param solh
 *		Matriz que devuleve las mejores jugdas(posicion, movimiento 
 *		y valor de cada jugada).
 */
__global__ void realizar_jugada_horizontal_cuda (int * mat1, Dim dimens, int * mat2,int * solh)
{
 
	int fila = blockIdx.x * blockDim.x + threadIdx.x;
	int aux = fila * dimens.columnas;
	   

	if ((fila >= dimens.filas)
		|| ( (blockIdx.y * blockDim.y + threadIdx.y) != 0) )
	{
		return;
	}
	for(int i = 0; i < dimens.filas * 4; i++){
		solh[i] = 0;
	}

	//Variable para recorrer la matriz
	int fin = 0;
	int cont = 0;
	int mov = 1;
	int ref = 0;

	//Vareables no definitivas para guardar el movimiento que se va a realizar
	
	int sen = 0;
	int posY = 0;
	int posX = 0;
	
	//Mejor movimiento horizontal
	
	int mh_valor = 0;
	int mh_sen = 0;  //Sentido del movimeinto
	int mh_posY = 0;
	int mh_posX = 0;
	

	for (int i = 0; i < dimens.columnas; i++)
	{
		ref = mat1[aux + i];

		for(int j = i; j < dimens.columnas; j ++)
		{
			if(fin == 0)
			{
				if(ref == mat1[aux + j])
				{
					//Mira si la posicion en la que esta es igual a la referencia
					cont ++;
				}
				else if((mov == 1)&&(fila > 0)&&(ref == mat1[aux - dimens.columnas + j]))
				{
					//Mira la posicion de arriba --> mover mat1[aux + j] arriba
					mov = 0;
					cont ++;

					sen = 3; posY = fila; posX = j;
				}
				else if((mov == 1)&&(fila < dimens.filas - 1)&&(ref == mat1[aux + dimens.columnas + j]))
				{
					//Mira la posicion de abajo --> mover mat1[aux + j] abajo
					mov = 0;
					cont ++;

					sen = 1; posY = fila;posX = j;
				}
				else if((mov == 1)&&((j + 1) < dimens.columnas)&&(ref == mat1[aux + j + 1]))
				{
					//Mirar la posicion de la derecha --> mover mat1[aux + j] derecha
					mov = 0;
					cont ++;

					sen = 0; posY = fila; posX = j;

					j++; //Pasa a comprobar la siguiente

				}
				else
				{
					fin = 1;
				}
			}
		}	
		//Mirar en las posiciones de la izquierda
		if ((mov == 1)&&(i > 0)&&(ref == mat1 [aux - dimens.columnas + i - 1]))
		{
			//Mirar la posicion por el lado de la izquierda arriba --> mover mat[aux + i - 1] arriba
			mov = 0;
			cont ++;

			sen = 3; posY = fila; posX = i - 1;
		}
		else if ((mov == 1)&&(i > 0)&&(ref == mat1 [aux + dimens.columnas + i -1]))
		{
			//Mirar la posicion por el lado de la izquierda abajo --> mover mat[aux + i - 1] abajo
			mov = 0;
			cont ++;

			sen = 1; posY = fila; posX = i - 1;
		}
		
		if(solh[fila * 4] <= cont){
			
			mh_sen = sen;
			if (mov == 1) sen = 4;
			mh_posY = posY;
			mh_posX = posX;
			
		}
		
		if((solh[fila * 4] == 0)||(solh [fila * 4] < cont))
		{
			solh[fila * 4] = cont;
			solh[(fila * 4) + 1] = mh_sen;
			solh[(fila * 4) + 2] = mh_posY;
			solh[(fila * 4) + 3] = mh_posX;
		}
		
		mat2[aux + i] = cont;
		
		//Reinicia valores
		mov = 1;
		fin = 0;
		cont = 0;
	}
}

/**
 * Busca las mejores jugadas por filas
 *
 * @return
 *		SUCCESS si todo ha salido correctamente.
 *		ERR_CUDA si hubo algún error al obtener las características del
 *	dispositivo.
 *		ERR_TAM si la matriz especificada sobrepasa las capacidades del
 *	dispositivo.
 */
int realizar_jugada_horizontal(Malla * malla,int * jugada)
{

	cudaError_t err;
	dim3 bloques, hilos;

	int tam = malla->dimens.columnas * malla->dimens.filas;
	
	int * matriz_d;
	int * mov_d;

	int * aux = (int *) malloc  (tam * sizeof aux [0]);

	//vector solh

	int * vec = (int *) malloc (malla->dimens.filas * sizeof (int) * 4);
	int * vec_d;

	cudaMalloc((void **) &vec_d,malla->dimens.filas * sizeof (int) * 4);

	for (int i = 0; i < malla->dimens.filas * 4; i++)
	{
		vec[i] = 0;
	}

	//Crea un hilo por columna
	Dim dim_matr_hilos;

	dim_matr_hilos.filas = malla->dimens.filas;
	dim_matr_hilos.columnas = 1;

	//Inicializa la matriz auxiliar 
	int idx;

	for (int i = 0; i < malla->dimens.filas; i++)
	{
		for (int j = 0; j < malla->dimens.columnas; j++)
		{
			idx = (i * malla->dimens.columnas) + j;
			aux[idx] = malla->matriz[idx].id;
		}
	}

	CUDA (err, cudaMalloc((void **)&matriz_d,tam * sizeof matriz_d[0]));

	CUDA (err, cudaMalloc((void **)&mov_d,tam * sizeof mov_d[0]));

	CUDA (err, cudaMemset(mov_d, NO_COINCIDE, tam * sizeof mov_d[0]));

	CUDA (err, cudaMemcpy(matriz_d, aux, tam * sizeof matriz_d [0],cudaMemcpyHostToDevice));

	cudaMemcpy (vec_d, &vec , sizeof (int) * malla->dimens.filas , cudaMemcpyHostToDevice);

	/* Llama al nucelo para comprar la matriz */
	obtener_dim (&bloques, &hilos, dim_matr_hilos);

	KERNEL (err, realizar_jugada_horizontal_cuda, bloques,hilos,matriz_d,malla->dimens,mov_d,vec_d);

	CUDA (err, cudaMemcpy(aux,mov_d, tam * sizeof aux [0], cudaMemcpyDeviceToHost));

	CUDA (err, cudaMemcpy(vec, vec_d, sizeof(int)*malla->dimens.filas *4,cudaMemcpyDeviceToHost));

	for (int i = 0; i < malla->dimens.filas; i++)
	{
		if(jugada[0]<vec[i * 4])
		{
			jugada[0] = vec[i * 4];
			jugada[1] = vec[i * 4 +1];
			jugada[2] = vec[i * 4 +2];
			jugada[3] = vec[i * 4 +3];
		}	
	}

	//copiar_matriz (aux, malla);

	CUDA (err, cudaFree(matriz_d));

	CUDA (err, cudaFree(mov_d));

	return SUCCESS;
}

/**
 * Busca las mejores jugadas por columnas
 *
 * @param matriz
 *		Matriz con los valores actuales de los diamantes.
 *
 * @param dimens
 *		Estructura con las dimensiones de la matriz.
 *
 * @param mat2
 *		Matriz en la que se va a indicar los valores de las mejores 
 *		jugadas por posicion
 *
 * @param solv
 *		Matriz que devuleve las mejores jugdas(posicion, movimiento 
 *		y valor de cada jugada).
 */
__global__ void realizar_jugada_vertical_cuda (int * mat1, Dim dimens, int * mat2, int * solv)
{

	int columna = blockIdx.y * blockDim.y + threadIdx.y;

	if ((columna >= dimens.columnas)
		|| ( (blockIdx.x * blockDim.x + threadIdx.x) != 0) )
	{
		return;
	}

	for(int i = 0;i < dimens.columnas * 4; i++){
		solv[i] = 0;
	}


	//Variable para recorrer la matriz
	int fin = 0;
	int cont = 0;
	int mov = 1;
	int ref = 0;

	//Vareables no definitivas para guardar el movimiento que se va a realizar
	
	int sen = 0;
	int posY = 0;
	int posX = 0;
	
	//Mejor movimiento horizontal
	
	int mh_valor = 0;
	int mh_sen = 0;  //Sentido del movimeinto
	int mh_posY = 0;
	int mh_posX = 0;
	

	for (int i = 0; i < dimens.filas; i++)
	{
		ref = mat1[dimens.columnas * i + columna];

		for(int j = i; j < dimens.filas; j ++)
		{
			if(fin == 0)
			{
				if(ref == mat1[dimens.columnas * j + columna])
				{
					//Mira si la posicion en la que esta es igual a la referencia
					cont ++;
				}
				
				else if((mov == 1)&&(columna > 0)&&(ref == mat1[dimens.columnas * j + columna - 1]))
				{
					//Mira la posicion de la izquierda --> mover mat1[dimens.columnas * j + columna - 1] izquierda
					mov = 0;
					cont ++;

					sen = 2; posY = j; posX = columna;
				}
				else if((mov == 1)&&(columna < dimens.columnas - 1)&&(ref == mat1[dimens.columnas * j + columna + 1]))
				{
					//Mira la posicion de la derecha --> mover mat1[dimens.columnas * j + columna + 1] derecha
					mov = 0;
					cont ++;

					sen = 0; posY = j;posX = columna;
				}
				
				else if((mov == 1)&&((j + 1) < dimens.filas)&&(ref == mat1[dimens.columnas * (j+1) + columna]))
				{
					//Mirar la posicion de abajo --> mover mat1[dimens.columnas * j + columna] abajo
					mov = 0;
					cont ++;

					sen = 1; posY = j; posX = columna;

					j++; //Pasa a comprobar la siguiente

				}
				else
				{
					fin = 1;
				}
			}
		}
		//Mirar en las posiciones de arriba
		if ((mov == 1)&&(columna > 0)&&(i>0)&&(ref == mat1 [dimens.columnas * (i- 1) + (columna - 1)]))
		{
			//Mirar la posicion por el lado de arriba izquierda --> mover mat[dimens.columnas * (i- 1) + (columna - 1)] izquierda
			mov = 0;
			cont ++;

			sen = 2; posY = i -1 ; posX =columna;
		}
		else if ((mov == 1)&&(i > 0)&&(columna + 1 < dimens.columnas)&&(ref == mat1 [dimens.columnas * (i - 1) + (columna + 1)]))
		{
			//Mirar la posicion por el lado de la arriba derecha --> mover mat[dimens.columnas * (i - 1) + (columna + 1)] derecha
			mov = 0;
			cont ++;

			sen = 0; posY = i - 1; posX = columna;
		}

		if(solv[columna * 4] <= cont){
	
			mh_sen = sen;
			if (mov == 1) sen = 4;
			mh_posY = posY;
			mh_posX = posX;
			
		}
		
		if((solv[columna * 4] == 0)||(solv[columna * 4] < cont))
		{
			solv[columna * 4] = cont;
			solv[(columna * 4) + 1] = mh_sen;
			solv[(columna * 4) + 2] = mh_posY;
			solv[(columna * 4) + 3] = mh_posX;	
		}
		
		mat2[dimens.columnas * i + columna] = cont;
		
		//Reinicias valores
		mov = 1;
		fin = 0;
		cont = 0;
	}

}

/**
 * Busca las mejores jugadas por columnas
 *
 * @return
 *		SUCCESS si todo ha salido correctamente.
 *		ERR_CUDA si hubo algún error al obtener las características del
 *	dispositivo.
 *		ERR_TAM si la matriz especificada sobrepasa las capacidades del
 *	dispositivo.
 */
int realizar_jugada_vertical(Malla * malla,int * jugada)
{

	cudaError_t err;
	dim3 bloques, hilos;

	int tam = malla->dimens.columnas * malla->dimens.filas;
	
	int * matriz_d;
	int * mov_d;

	int * aux = (int *) malloc  (tam * sizeof aux [0]);

	int * vec = (int *) malloc (malla->dimens.columnas * sizeof (int) * 4);
	int * vec_d;

	cudaMalloc((void **) &vec_d,malla->dimens.columnas * sizeof (int) * 4);

	for (int i = 0; i < malla->dimens.columnas * 4; i++)
	{
		vec[i] = 0;
	}

	//Crea un hilo por fila
	Dim dim_matr_hilos;

	dim_matr_hilos.filas = 1;
	dim_matr_hilos.columnas = malla->dimens.columnas;

	//Inicializa la matriz auxiliar 
	int idx;

	for (int i = 0; i < malla->dimens.filas; i++)
	{

		for (int j = 0; j < malla->dimens.columnas; j++)
		{
			idx = (i * malla->dimens.columnas) + j;
			aux[idx] = malla->matriz[idx].id;
		}
	}
	

	CUDA (err, cudaMalloc((void **)&matriz_d,tam * sizeof matriz_d[0]));

	CUDA (err, cudaMalloc((void **)&mov_d,tam * sizeof mov_d[0]));

	CUDA (err, cudaMemset(mov_d, NO_COINCIDE, tam * sizeof mov_d[0]));

	CUDA (err, cudaMemcpy(matriz_d, aux, tam * sizeof matriz_d [0],cudaMemcpyHostToDevice));

	cudaMemcpy( vec_d, &vec,sizeof (int) * malla->dimens.columnas, cudaMemcpyHostToDevice );

	obtener_dim (&bloques, &hilos, dim_matr_hilos);

	KERNEL (err, realizar_jugada_vertical_cuda, bloques,hilos,matriz_d,malla->dimens,mov_d,vec_d);

	CUDA (err, cudaMemcpy(aux,mov_d, tam * sizeof aux [0], cudaMemcpyDeviceToHost));
	
	CUDA (err, cudaMemcpy(vec, vec_d,sizeof (int) * malla->dimens.columnas * 4, cudaMemcpyDeviceToHost ));
	
	for (int i = 0; i < malla->dimens.columnas; i++)
	{
		if(jugada[0]<vec[i * 4])
		{
			jugada[0] = vec[i * 4];
			jugada[1] = vec[i * 4 +1];
			jugada[2] = vec[i * 4 +2];
			jugada[3] = vec[i * 4 +3];
		}	
	}

	CUDA (err, cudaFree(matriz_d));

	CUDA (err, cudaFree(mov_d));

	return SUCCESS;
}

int realizar_jugada(Malla * malla)
{
	int jugada_v[4];
	int jugada_h[4];

	int posY;
	int posX;
	int mov;

	realizar_jugada_vertical(malla,jugada_v);
	realizar_jugada_horizontal(malla,jugada_h);

	if(jugada_v[0]>jugada_h[0])
	{
		printf("Mejor jugada --> Mov(%d): %d PosY: %d PosX: %d\n",jugada_v[0],jugada_v[1],jugada_v[2],jugada_v[3]);
		posY = jugada_v[2];
		posX = jugada_v[3];
		mov = jugada_v[1];
	}
	else
	{
		printf("Mov(%d): %d PosY: %d PosX: %d\n",jugada_h[0],jugada_h[1],jugada_h[2],jugada_h[3]);
		posY = jugada_h[2];
		posX = jugada_h[3];
		mov = jugada_h[1];
	}
	mover_diamante(posY,posX,mov,* malla);
	return SUCCESS;
}